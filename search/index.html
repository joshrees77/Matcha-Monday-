<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matcha Search</title>
  
  <!-- PWA Configuration -->
  <meta name="theme-color" content="#90a955">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Matcha Search">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.5;
      color: #333;
      background: #f0f6ea;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
    }

    .header {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eee;
      position: relative;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 400;
      margin-bottom: 5px;
      color: #000;
    }

    .header p {
      color: #666;
      font-size: 14px;
    }

    .header a {
      color: #666;
    }

    .settings-button {
      position: absolute;
      top: 0;
      right: 0;
      padding: 8px 12px;
      background: #f5f5f5;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 14px;
      color: #333;
      border-radius: 20px;
    }

    .settings-button:hover {
      background: #eee;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border: 1px solid #ccc;
      max-width: 400px;
      width: 90%;
      border-radius: 20px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .modal-title {
      font-size: 16px;
      font-weight: 500;
      color: #000;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 20px;
      height: 20px;
      display: none; /* Hide on all devices - use outside click to close */
    }

    .close-button:hover {
      color: #000;
    }

    .model-selector {
      margin-bottom: 15px;
    }

    .model-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .model-controls label {
      font-size: 14px;
      color: #333;
    }

    .model-controls select {
      flex: 1;
      min-width: 200px;
      padding: 8px;
      border: 1px solid #ccc;
      font-size: 14px;
      background: white;
      border-radius: 20px;
    }

    .model-controls button {
      padding: 8px 16px;
      background: #eee;
      color: #333;
      border: 1px solid #ccc;
      font-size: 14px;
      cursor: pointer;
      border-radius: 20px;
    }

    .model-controls button:hover:not(:disabled) {
      background: #ddd;
    }

    .model-controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .loader-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 40px 0;
      text-align: center;
    }

    .loader-container.hidden {
      display: none;
    }

    .matcha-loader {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }

    .status-text {
      font-size: 14px;
      color: #666;
    }

    .status-text.error {
      color: #d00;
    }

    .search-container {
      margin-bottom: 30px;
    }

    .search-container.hidden {
      display: none;
    }

    .search-input-group {
      display: flex;
      gap: 10px;
    }

    .search-input {
      flex: 1;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 20px;
    }

    .search-input:focus {
      outline: none;
      border-color: #666;
    }

    .search-input:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    .search-button {
      padding: 10px 20px;
      background: #000;
      color: white;
      border: none;
      font-size: 16px;
      cursor: pointer;
      border-radius: 20px;
    }

    .search-button:hover:not(:disabled) {
      background: #333;
    }

    .search-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .result-item {
      padding: 20px;
      border: 1px solid #eee;
      margin-bottom: 15px;
      background: white;
      border-radius: 20px;
    }

    .result-title {
      font-size: 18px;
      font-weight: 500;
      margin-bottom: 8px;
    }

    .result-title a {
      color: #000;
      text-decoration: none;
    }

    .result-title a:hover {
      text-decoration: underline;
    }

    .result-author {
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
    }

    .result-description {
      color: #333;
      margin-bottom: 10px;
      line-height: 1.4;
    }

    .result-similarity {
      font-size: 12px;
      color: #999;
    }

    .show-more-container {
      text-align: center;
      margin: 20px 0;
    }

    .show-more-btn {
      padding: 8px 16px;
      background: #f5f5f5;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 14px;
      color: #333;
      border-radius: 20px;
    }

    .show-more-btn:hover {
      background: #eee;
    }

    .no-results {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .searching {
      text-align: center;
      padding: 20px;
      color: #333;
    }

    .background-indicator {
      display: none;
      align-items: center;
      gap: 8px;
      background: #f8f9fa;
      border: 1px solid #e5e7eb;
      border-radius: 20px;
      padding: 6px 12px;
      margin-bottom: 15px;
      font-size: 13px;
      color: #6b7280;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .background-indicator:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
    }

    .background-indicator.visible {
      display: flex;
    }

    .background-indicator-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .background-indicator-text {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .background-indicator-chevron {
      font-size: 10px;
      transition: transform 0.2s ease;
      color: #9ca3af;
    }

    .background-indicator.expanded .background-indicator-chevron {
      transform: rotate(180deg);
    }

    .background-progress {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #e5e7eb;
      border-top: none;
      border-radius: 0 0 8px 8px;
      padding: 12px;
      font-size: 12px;
      color: #6b7280;
      z-index: 10;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .background-progress.visible {
      display: block;
    }

    .progress-item {
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .progress-item:last-child {
      margin-bottom: 0;
    }

    .progress-status {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 500;
    }

    .progress-status.processing {
      background: #fef3c7;
      color: #92400e;
    }

    .progress-status.complete {
      background: #d1fae5;
      color: #065f46;
    }

    .progress-status.pending {
      background: #f3f4f6;
      color: #6b7280;
    }

    /* Mobile */
    @media (max-width: 600px) {
      body {
        padding: 15px;
      }

      .model-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .model-controls select {
        min-width: auto;
      }

      .search-input-group {
        flex-direction: column;
      }

      .result-item {
        padding: 15px;
      }
    }
  </style>
  <script type="module">
    import {pipeline} from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.1';

    const ring = [
      {
        url: "https://maxbo.me",
        name: "Max Bo",
        feed: "https://maxbo.me/atom.xml",
      },
      {
        url: "https://liamzebedee.com",
        name: "Liam Zebedee",
        feed: "https://liamzebedee.com/index.xml",
      },
      {
        url: "https://borretti.me",
        name: "Fernando Borretti",
        feed: "https://borretti.me/feed.xml",
      },
      {
        url: "https://ethansmith2000.com",
        name: "Ethan Smith",
        feed: "https://www.ethansmith2000.com/blog-feed.xml",
      },
      {
        url: "https://tomlister.net",
        name: "Tom Lister",
        feed: "https://tomlister.net/feed.xml",
      }
    ];

    const proxyURL = "https://tomlister--95ced61c6f4c11f0bd4b0224a6c84d84.web.val.run/?feed=";

    let embedder = null;
    let isLoadingModel = false;
    let loadingTimer = null;
    let loadingStartTime = null;

    const availableModels = [
      {id: 'Xenova/all-MiniLM-L6-v2', name: 'MiniLM L6 v2 (Fast, Small)', size: '~23MB'},
      {id: 'Xenova/all-mpnet-base-v2', name: 'MPNet Base v2 (Better Quality)', size: '~438MB'},
      {id: 'Xenova/bge-small-en-v1.5', name: 'BGE Small (Balanced)', size: '~133MB'},
      {id: 'Xenova/sentence-transformers-all-MiniLM-L6-v2', name: 'Sentence Transformers MiniLM', size: '~91MB'}
    ];

    const initEmbeddings = async (modelId = 'Xenova/all-MiniLM-L6-v2') => {
      if (embedder && embedder.model && embedder.model.config.name_or_path === modelId) {
        console.log("Same model already loaded");
        return embedder;
      }

      if (isLoadingModel) {
        console.log("Model loading in progress...");
        return null;
      }

      if (embedder) {
        console.log("Clearing previous model...");
        embedder = null;
        window.embedder = null;
      }

      isLoadingModel = true;
      loadingStartTime = Date.now();
      let isFromCache = false;

      const updateTimer = () => {
        const elapsed = Math.floor((Date.now() - loadingStartTime) / 1000);
        const statusDiv = document.getElementById('statusText');
        if (statusDiv && !statusDiv.textContent.includes('Downloading') && !statusDiv.textContent.includes('Loading from cache')) {
          statusDiv.textContent = `Loading model: ${elapsed}s`;
        }
      };

      loadingTimer = setInterval(updateTimer, 1000);
      updateTimer();

      try {
        console.log(`Loading embedding model: ${modelId}`);
        embedder = await pipeline('feature-extraction', modelId, {
          dtype: 'q8',
          progress_callback: (progress) => {
            const elapsed = Math.floor((Date.now() - loadingStartTime) / 1000);
            const statusDiv = document.getElementById('statusText');
            if (progress.status === 'download') {
              if (statusDiv) {
                statusDiv.textContent = `Downloading ${progress.name}: ${elapsed}s`;
              }
            } else if (progress.status === 'ready') {
              isFromCache = elapsed < 2; // If very fast, likely from cache
              if (statusDiv && isFromCache) {
                statusDiv.textContent = `Loading from cache: ${elapsed}s`;
              }
            }
          }
        });
        window.embedder = embedder;
        console.log(`Embedding model loaded: ${modelId}${isFromCache ? ' (from cache)' : ''}`);
        return embedder;
      } finally {
        isLoadingModel = false;
        if (loadingTimer) {
          clearInterval(loadingTimer);
          loadingTimer = null;
        }
      }
    };

    const getFeedProxy = async ({feed, name, modelId}) => {
      const response = await fetch(proxyURL + feed);
      const text = await response.text();
      const parser = new DOMParser();
      const xml = parser.parseFromString(text, "application/xml");
      return await parseFeed(xml, name, modelId);
    }

    const parseFeed = async (xml, authorName, modelId) => {
      const isAtom = xml.querySelector("feed") || xml.querySelector("entry");
      const isRSS = xml.querySelector("rss") || xml.querySelector("item");

      let items;
      if (isAtom) {
        items = xml.querySelectorAll("entry");
        console.log(`Processing Atom feed for ${authorName} with model ${modelId}...`);
      } else if (isRSS) {
        items = xml.querySelectorAll("item");
        console.log(`Processing RSS feed for ${authorName} with model ${modelId}...`);
      } else {
        console.warn(`Unknown feed format for ${authorName} with model ${modelId}, trying both entry and item selectors...`);
        items = xml.querySelectorAll("entry, item");
      }

      const results = [];
      const maxItems = 15;

      const itemsToProcess = Array.from(items).slice(0, maxItems);
      const cachedArticles = loadCachedArticles(modelId);

      console.log(`Processing ${itemsToProcess.length} items from feed for ${authorName} with model ${modelId}...`);

      for (const item of itemsToProcess) {
        let title, description, link;

        if (isAtom) {
          title = item.querySelector("title")?.textContent || "";
          description = item.querySelector("summary")?.textContent ||
            item.querySelector("content")?.textContent || "";
          const linkEl = item.querySelector("link");
          if (linkEl) {
            link = linkEl.getAttribute("href") || linkEl.textContent || "";
          } else {
            link = "";
          }
        } else {
          title = item.querySelector("title")?.textContent || "";
          // Try content:encoded first (full content), then fall back to description
          const contentEncoded = item.querySelector("content\\:encoded")?.textContent || 
                                 item.querySelector("encoded")?.textContent || "";
          description = contentEncoded || 
                       item.querySelector("description")?.textContent || "";
          link = item.querySelector("link")?.textContent || "";
        }

        if (!title.trim()) continue;

        // Generate hash for this article
        const articleData = { title, link, author: authorName };
        const articleHash = generateArticleHash(articleData);

        // Check if we have this article in cache
        if (cachedArticles[articleHash]) {
          console.log("Using cached article:", title.substring(0, 40) + "...");
          results.push({
            ...cachedArticles[articleHash],
            author: authorName // Ensure author is set correctly
          });
          continue;
        }

        // Strip HTML tags from description if it contains them
        let cleanDescription = description;
        if (description.includes('<')) {
          // Use DOMParser to safely parse HTML without triggering resource loads
          const parser = new DOMParser();
          const doc = parser.parseFromString(description, 'text/html');
          cleanDescription = doc.body?.textContent || doc.body?.innerText || '';
        }

        console.log("Processing new article:", title.substring(0, 60) + "...");

        let embedding = null;
        const currentEmbedder = embedder || window.embedder;
        if (currentEmbedder && title) {
          try {
            // Use more content for better embeddings, but limit to 2000 chars for performance
            const textToEmbed = (title + " " + cleanDescription).substring(0, 2000);
            const embeddingResult = await currentEmbedder(textToEmbed, {
              pooling: 'mean',
              normalize: true
            });
            embedding = Array.from(embeddingResult.data);
          } catch (error) {
            console.error("Failed to generate embedding for:", title.substring(0, 40), error);
            throw error;
          }
        } else {
          throw new Error("Embedding model not available!");
        }

        const processedArticle = {
          title,
          description: cleanDescription.substring(0, 500),
          link,
          embedding,
          author: authorName
        };

        // Cache this article
        cachedArticles[articleHash] = processedArticle;
        results.push(processedArticle);
      }

      // Save updated cache
      saveCachedArticles(cachedArticles, modelId);

      console.log(`Processed ${results.length} items with embeddings for ${authorName} with model ${modelId}`);
      return results;
    }

    const getFeeds = async (currentModelId, isBackground = false) => {
      const allFeeds = [];
      const totalFeeds = ring.length;
      const progressItems = [];
      
      // Initialize progress items
      ring.forEach(author => {
        progressItems.push({
          text: author.name,
          status: 'pending'
        });
      });
      
      if (isBackground) {
        window.updateBackgroundProgress(progressItems);
      }
      
      for (let i = 0; i < ring.length; i++) {
        const author = ring[i];
        const progress = i + 1;
        
        // Update progress item status
        progressItems[i].status = 'processing';
        
        if (isBackground) {
          window.updateBackgroundProgress(progressItems);
          const indicatorText = document.getElementById('backgroundIndicatorText');
          if (indicatorText) {
            indicatorText.textContent = `Processing feeds (${progress}/${totalFeeds})...`;
          }
        } else {
          // Update status with progress for initial load
          if (window.updateStatus) {
            window.updateStatus(`Processing feeds (${progress}/${totalFeeds}): ${author.name}...`);
          }
        }
        
        try {
          const feedItems = await getFeedProxy({
            feed: author.feed, 
            name: author.name, 
            modelId: currentModelId
          });
          allFeeds.push(...feedItems);
          progressItems[i].status = 'complete';
        } catch (error) {
          console.error(`Failed to process feed for ${author.name}:`, error);
          progressItems[i].status = 'pending'; // Reset to pending on error
          // Continue with other feeds even if one fails
        }
        
        if (isBackground) {
          window.updateBackgroundProgress(progressItems);
        }
      }
      
      return allFeeds;
    }

    const cosineSimilarity = (a, b) => {
      const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
      const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
      const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
      return dotProduct / (magnitudeA * magnitudeB);
    };

    // Cache management functions
    const CACHE_KEY = 'matcha_search_cache';
    const MODEL_PREF_KEY = 'matcha_model_preference';
    const CACHE_VERSION = '1.0';

    const saveModelPreference = (modelId) => {
      try {
        localStorage.setItem(MODEL_PREF_KEY, modelId);
      } catch (error) {
        console.warn('Failed to save model preference:', error);
      }
    };

    const loadModelPreference = () => {
      try {
        return localStorage.getItem(MODEL_PREF_KEY) || 'Xenova/all-MiniLM-L6-v2';
      } catch (error) {
        console.warn('Failed to load model preference:', error);
        return 'Xenova/all-MiniLM-L6-v2';
      }
    };

    const generateArticleHash = (article) => {
      // Create a simple hash from title + link + author for cache key
      const text = `${article.title}|${article.link}|${article.author}`;
      let hash = 0;
      for (let i = 0; i < text.length; i++) {
        const char = text.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return hash.toString();
    };

    const loadCachedArticles = (modelId) => {
      try {
        const cached = localStorage.getItem(CACHE_KEY);
        if (!cached) return {};
        
        const data = JSON.parse(cached);
        if (data.version !== CACHE_VERSION || data.modelId !== modelId) {
          console.log('Cache version mismatch or different model, clearing cache');
          localStorage.removeItem(CACHE_KEY);
          return {};
        }
        
        console.log(`Loaded ${Object.keys(data.articles || {}).length} cached articles`);
        return data.articles || {};
      } catch (error) {
        console.warn('Failed to load cached articles:', error);
        return {};
      }
    };

    const saveCachedArticles = (articles, modelId) => {
      try {
        const cacheData = {
          version: CACHE_VERSION,
          modelId: modelId,
          timestamp: Date.now(),
          articles: articles
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
        console.log(`Cached ${Object.keys(articles).length} articles`);
      } catch (error) {
        console.warn('Failed to save cached articles:', error);
      }
    };

    const clearCache = () => {
      try {
        localStorage.removeItem(CACHE_KEY);
        console.log('Cache cleared');
      } catch (error) {
        console.warn('Failed to clear cache:', error);
      }
    };

    const searchItems = async (query, items, topK = 5) => {
      const currentEmbedder = embedder || window.embedder;

      if (!currentEmbedder) {
        throw new Error("Embedding model not loaded! Cannot perform semantic search.");
      }

      if (!query.trim()) return [];

      console.log(`Searching for: "${query}"`);

      const queryEmbedding = await currentEmbedder(query, {pooling: 'mean', normalize: true});
      const queryVector = Array.from(queryEmbedding.data);

      const results = items
        .filter(item => item.embedding)
        .map(item => ({
          ...item,
          similarity: (cosineSimilarity || window.cosineSimilarity)(queryVector, item.embedding)
        }))
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, topK);

      console.log(`Found ${results.length} results`);
      return results;
    };

    let allFeedItems = [];

    const populateModelSelect = () => {
      const modelSelect = document.getElementById('modelSelect');
      modelSelect.innerHTML = '';

      const savedModel = window.loadModelPreference();

      window.availableModels.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = `${model.name} (${model.size})`;
        if (model.id === savedModel) {
          option.selected = true;
        }
        modelSelect.appendChild(option);
      });
    };

    const updateStatus = (text, isError = false, hideLoader = false) => {
      const statusText = document.getElementById('statusText');
      const loaderContainer = document.getElementById('loaderContainer');
      const searchContainer = document.getElementById('searchContainer');
      
      statusText.textContent = text;
      statusText.className = isError ? 'status-text error' : 'status-text';
      
      if (hideLoader) {
        loaderContainer.classList.add('hidden');
        searchContainer.classList.remove('hidden');
      } else {
        loaderContainer.classList.remove('hidden');
        searchContainer.classList.add('hidden');
      }
    };

    const main = async () => {
      const searchInput = document.getElementById('searchInput');
      const searchButton = document.getElementById('searchButton');
      const modelSelect = document.getElementById('modelSelect');

      populateModelSelect();

      window.handleModelChange();

      try {
        const selectedModel = modelSelect.value;
        window.updateStatus(`Loading embedding model: ${selectedModel}...`);

        await window.initEmbeddings(selectedModel);

        // Check for cached data
        const cachedArticles = window.loadCachedArticles(selectedModel);
        const hasCachedData = Object.keys(cachedArticles).length > 0;

        if (hasCachedData) {
          // Load cached articles immediately
          allFeedItems = Object.values(cachedArticles);
          window.allFeedItems = allFeedItems;
          console.log(`Loaded ${allFeedItems.length} cached blog posts.`);

          // Enable search immediately
          window.updateStatus(`Loaded ${allFeedItems.length} cached blog posts. Updating feeds in background...`, false, true);
          searchInput.disabled = false;
          searchButton.disabled = false;
          searchInput.focus();

          // Show background indicator and start background processing
          window.showBackgroundIndicator('Updating feeds...');

                        // Process feeds in background
              setTimeout(async () => {
                try {
                  console.log("Background fetching feeds...");
                  const backgroundFeedItems = await window.getFeeds(selectedModel, true);
                  
                  // Calculate new articles by comparing with cached data
                  const cachedCount = allFeedItems.length;
                  const newCount = backgroundFeedItems.length - cachedCount;
                  
                  // Update with new data
                  allFeedItems = backgroundFeedItems;
                  window.allFeedItems = allFeedItems;
                  console.log(`Background processed ${backgroundFeedItems.length} blog posts.`);

                  // Update indicator text with format "n posts - n new"
                  const indicatorText = document.getElementById('backgroundIndicatorText');
                  if (indicatorText) {
                    if (newCount > 0) {
                      indicatorText.textContent = `${backgroundFeedItems.length} posts - ${newCount} new`;
                    } else {
                      indicatorText.textContent = `${backgroundFeedItems.length} posts - up to date`;
                    }
                  }
                  
                  setTimeout(() => {
                    window.hideBackgroundIndicator();
                  }, 3000);

                } catch (error) {
                  console.error("Error in background processing:", error);
                  const indicatorText = document.getElementById('backgroundIndicatorText');
                  if (indicatorText) {
                    indicatorText.textContent = 'Update failed - click for details';
                  }
                }
              }, 100);

        } else {
          // No cached data - process feeds normally
          window.updateStatus("Processing feeds...");

          console.log("Fetching feeds...");
          allFeedItems = await window.getFeeds(selectedModel);
          window.allFeedItems = allFeedItems;
          console.log(`Processed ${allFeedItems.length} blog posts.`);

          // Hide loader and show search
          window.updateStatus(`Loaded ${allFeedItems.length} blog posts.`, false, true);
          searchInput.disabled = false;
          searchButton.disabled = false;
          searchInput.focus();
        }

      } catch (error) {
        console.error("Error in main:", error);
        window.updateStatus("Failed to load embedding model. Check console for details.", true);
      }
    };

    // Expose functions to window for cross-context access
    window.searchItems = searchItems;
    window.allFeedItems = allFeedItems;
    window.cosineSimilarity = cosineSimilarity;
    window.availableModels = availableModels;
    window.initEmbeddings = initEmbeddings;
    window.getFeeds = getFeeds;
    window.clearCache = clearCache;
    window.loadCachedArticles = loadCachedArticles;
    window.saveCachedArticles = saveCachedArticles;
    window.saveModelPreference = saveModelPreference;
    window.loadModelPreference = loadModelPreference;
    window.CACHE_KEY = CACHE_KEY;
    window.updateStatus = updateStatus;

    document.addEventListener("DOMContentLoaded", () => {
      main();
    })
  </script>
</head>

<body>
  <div class="header">
    <h1>matcha search</h1>
    <p>semantically searches the collective knowledge of the <a href="https://matchamonday.net">matcha monday</a> webring</p>
    <button class="settings-button" onclick="openSettings()"><i class="fas fa-cog"></i></button>
  </div>

  <div id="loaderContainer" class="loader-container">
    <img src="../matcha.gif" alt="Loading..." class="matcha-loader">
    <div id="statusText" class="status-text">Loading embedding model...</div>
  </div>

  <div id="searchContainer" class="search-container hidden">
    <div id="backgroundIndicator" class="background-indicator" onclick="toggleBackgroundProgress()">
      <img src="../matcha.gif" alt="Processing..." class="background-indicator-icon">
      <span id="backgroundIndicatorText" class="background-indicator-text">Updating feeds...</span>
      <span class="background-indicator-chevron">â–¼</span>
      <div id="backgroundProgress" class="background-progress">
        <div id="progressItems"></div>
      </div>
    </div>
    <div class="search-input-group">
      <input type="text" id="searchInput" class="search-input" placeholder="Search blog posts..." disabled>
      <button onclick="performSearch()" class="search-button" disabled id="searchButton">Search</button>
    </div>
  </div>

  <div id="results" class="results"></div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Settings</div>
        <button class="close-button" onclick="closeSettings()">&times;</button>
      </div>
      <div class="model-selector">
        <div class="model-controls">
          <label for="modelSelect">Model:</label>
          <select id="modelSelect" onchange="handleModelChange()"></select>
          <button onclick="reloadModel()" id="reloadButton">Load</button>
        </div>
      </div>
      <div class="cache-management">
        <div class="model-controls">
          <label>Cache:</label>
          <button onclick="clearAllCaches()" id="clearAllButton">Clear Cache</button>
        </div>
        <div id="cacheInfo" style="font-size: 12px; color: #666; margin-top: 10px; line-height: 1.4;"></div>
      </div>
    </div>
  </div>

  <script>
    window.openSettings = () => {
      document.getElementById('settingsModal').style.display = 'block';
    };

    window.closeSettings = () => {
      document.getElementById('settingsModal').style.display = 'none';
    };

    // Close modal when clicking outside of it
    window.onclick = (event) => {
      const modal = document.getElementById('settingsModal');
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    };

    window.handleModelChange = () => {
      const modelSelect = document.getElementById('modelSelect');
      const reloadButton = document.getElementById('reloadButton');
      const selectedModel = window.availableModels.find(m => m.id === modelSelect.value);

      if (selectedModel) {
        reloadButton.textContent = `Load`;
        // Save the model preference
        window.saveModelPreference(modelSelect.value);
      }
    };



    window.reloadModel = async () => {
      const searchInput = document.getElementById('searchInput');
      const searchButton = document.getElementById('searchButton');
      const modelSelect = document.getElementById('modelSelect');
      const reloadButton = document.getElementById('reloadButton');

      searchInput.disabled = true;
      searchButton.disabled = true;
      reloadButton.disabled = true;

      window.allFeedItems = [];

      try {
        const selectedModel = modelSelect.value;
        
        // Show loader and hide search
        const searchContainer = document.getElementById('searchContainer');
        const loaderContainer = document.getElementById('loaderContainer');
        searchContainer.classList.add('hidden');
        loaderContainer.classList.remove('hidden');
        
        window.updateStatus(`Loading embedding model: ${selectedModel}...`);

        await window.initEmbeddings(selectedModel);

        window.updateStatus("Processing feeds with new model...");

        const newFeedItems = await window.getFeeds(selectedModel);
        window.allFeedItems = newFeedItems;

        window.updateStatus(`Loaded ${newFeedItems.length} blog posts.`, false, true);
        searchInput.disabled = false;
        searchButton.disabled = false;
        searchInput.focus();

      } catch (error) {
        console.error("Error loading model:", error);
        window.updateStatus("Failed to load model. Check console for details.", true);
      } finally {
        reloadButton.disabled = false;
      }
    };

    window.performSearch = async () => {
      const query = document.getElementById('searchInput').value;
      if (!query.trim()) return;

      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '<div class="searching">Searching...</div>';

      try {
        console.log('Searching for:', query);
        console.log('Available items:', window.allFeedItems?.length);
        console.log('Embedder available:', !!window.embedder);

        const results = await window.searchItems(query, window.allFeedItems);

        if (results.length === 0) {
          resultsDiv.innerHTML = '<div class="no-results">No results found.</div>';
          return;
        }

        const threshold = 0.30;
        const highQualityResults = results.filter(item => item.similarity >= threshold);
        const lowQualityResults = results.filter(item => item.similarity < threshold);

        const renderResults = (items, showSimilarity = true) => {
          return items.map(item => `
            <div class="result-item">
              <div class="result-title"><a href="${item.link}" target="_blank">${item.title}</a></div>
              <div class="result-author">By ${item.author}</div>
              <div class="result-description">${item.description || 'No description available'}</div>
              ${showSimilarity ? `<div class="result-similarity">Similarity: ${(item.similarity * 100).toFixed(1)}%</div>` : ''}
            </div>
          `).join('');
        };

        let html = '';
        if (highQualityResults.length > 0) {
          html += renderResults(highQualityResults);
        } else {
          html += '<div class="no-results">No high-confidence results found.</div>';
        }

        if (lowQualityResults.length > 0) {
          html += `
            <div id="showMoreContainer" class="show-more-container">
              <button id="showMoreBtn" onclick="toggleLowQualityResults()" class="show-more-btn">
                Show ${lowQualityResults.length} more result${lowQualityResults.length > 1 ? 's' : ''} (lower similarity)
              </button>
            </div>
            <div id="lowQualityResults" style="display: none;">
              ${renderResults(lowQualityResults)}
            </div>
          `;
        }

        resultsDiv.innerHTML = html;

      } catch (error) {
        resultsDiv.innerHTML = '<div class="no-results">Search error. Check console for details.</div>';
        console.error('Search error:', error);
      }
    };

    window.toggleLowQualityResults = () => {
      const lowQualityDiv = document.getElementById('lowQualityResults');
      const showMoreBtn = document.getElementById('showMoreBtn');

      if (lowQualityDiv.style.display === 'none') {
        lowQualityDiv.style.display = 'block';
        showMoreBtn.textContent = 'Hide lower similarity results';
      } else {
        lowQualityDiv.style.display = 'none';
        const hiddenCount = lowQualityDiv.children.length;
        showMoreBtn.textContent = `Show ${hiddenCount} more result${hiddenCount > 1 ? 's' : ''} (lower similarity)`;
      }
    };

    document.getElementById('searchInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        performSearch();
      }
    });



    // Cache management with service worker communication
    window.getCacheInfo = async () => {
      if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) {
        return null;
      }

      return new Promise((resolve) => {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          if (event.data.type === 'CACHE_INFO') {
            resolve(event.data.data);
          }
        };
        
        navigator.serviceWorker.controller.postMessage(
          { type: 'GET_CACHE_INFO' },
          [messageChannel.port2]
        );
      });
    };



    window.clearAllCaches = async () => {
      if (confirm('This will clear all cached data and reload the page. Continue?')) {
        // Clear localStorage
        window.clearCache();
        
        // Clear service worker caches if available
        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
          const messageChannel = new MessageChannel();
          messageChannel.port1.onmessage = (event) => {
            if (event.data.type === 'ALL_CACHE_CLEARED') {
              location.reload();
            }
          };
          
          navigator.serviceWorker.controller.postMessage(
            { type: 'CLEAR_ALL_CACHE' },
            [messageChannel.port2]
          );
        } else {
          // Fallback if service worker not available
          location.reload();
        }
      }
    };

    window.formatBytes = (bytes) => {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    };

    window.updateCacheInfo = async () => {
      const cacheInfo = document.getElementById('cacheInfo');
      
      if (cacheInfo) {
        try {
          // LocalStorage cache info
          const cached = localStorage.getItem(window.CACHE_KEY);
          let dataInfo = '';
          if (cached) {
            const data = JSON.parse(cached);
            const itemCount = Object.keys(data.articles || {}).length;
            const size = (new Blob([cached]).size / 1024).toFixed(1);
            dataInfo = `Articles: ${itemCount} (${size}KB)`;
          } else {
            dataInfo = 'Articles: None cached';
          }

          // Service Worker cache info
          const swCacheInfo = await getCacheInfo();
          if (swCacheInfo) {
            const modelSize = formatBytes(swCacheInfo.models.size);
            const totalSize = formatBytes(swCacheInfo.total.size);
            
            cacheInfo.innerHTML = `
              ${dataInfo}<br>
              Models: ${swCacheInfo.models.count} files (${modelSize})<br>
              Total Storage: ${totalSize}
            `;
          } else {
            cacheInfo.textContent = dataInfo;
          }
        } catch (error) {
          cacheInfo.textContent = 'Error reading cache info';
        }
      }
    };

    window.toggleBackgroundProgress = () => {
      const indicator = document.getElementById('backgroundIndicator');
      const progress = document.getElementById('backgroundProgress');
      
      if (indicator.classList.contains('expanded')) {
        indicator.classList.remove('expanded');
        progress.classList.remove('visible');
      } else {
        indicator.classList.add('expanded');
        progress.classList.add('visible');
      }
    };

    window.showBackgroundIndicator = (text = 'Updating feeds...') => {
      const indicator = document.getElementById('backgroundIndicator');
      const indicatorText = document.getElementById('backgroundIndicatorText');
      
      indicatorText.textContent = text;
      indicator.classList.add('visible');
    };

    window.hideBackgroundIndicator = () => {
      const indicator = document.getElementById('backgroundIndicator');
      const progress = document.getElementById('backgroundProgress');
      
      indicator.classList.remove('visible', 'expanded');
      progress.classList.remove('visible');
    };

    window.updateBackgroundProgress = (items) => {
      const progressItems = document.getElementById('progressItems');
      
      progressItems.innerHTML = items.map(item => `
        <div class="progress-item">
          <span class="progress-status ${item.status}">${item.status}</span>
          <span>${item.text}</span>
        </div>
      `).join('');
    };

    // Update cache info when settings modal opens
    const originalOpenSettings = window.openSettings;
    window.openSettings = () => {
      originalOpenSettings();
      setTimeout(updateCacheInfo, 100);
    };

    // Register service worker for PWA functionality
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/search/sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration);
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }
  </script>
</body>

</html>
