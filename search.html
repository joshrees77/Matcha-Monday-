<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matcha Search</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.5;
      color: #333;
      background: #f0f6ea;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
    }

    .header {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eee;
      position: relative;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 400;
      margin-bottom: 5px;
      color: #000;
    }

    .header p {
      color: #666;
      font-size: 14px;
    }

    .header a {
      color: #666;
    }

    .settings-button {
      position: absolute;
      top: 0;
      right: 0;
      padding: 8px 12px;
      background: #f5f5f5;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 14px;
      color: #333;
    }

    .settings-button:hover {
      background: #eee;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border: 1px solid #ccc;
      max-width: 400px;
      width: 90%;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .modal-title {
      font-size: 16px;
      font-weight: 500;
      color: #000;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 20px;
      height: 20px;
    }

    .close-button:hover {
      color: #000;
    }

    .model-selector {
      margin-bottom: 15px;
    }

    .model-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .model-controls label {
      font-size: 14px;
      color: #333;
    }

    .model-controls select {
      flex: 1;
      min-width: 200px;
      padding: 8px;
      border: 1px solid #ccc;
      font-size: 14px;
      background: white;
    }

    .model-controls button {
      padding: 8px 16px;
      background: #eee;
      color: #333;
      border: 1px solid #ccc;
      font-size: 14px;
      cursor: pointer;
    }

    .model-controls button:hover:not(:disabled) {
      background: #ddd;
    }

    .model-controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .loader-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 40px 0;
      text-align: center;
    }

    .loader-container.hidden {
      display: none;
    }

    .matcha-loader {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }

    .status-text {
      font-size: 14px;
      color: #666;
    }

    .status-text.error {
      color: #d00;
    }

    .search-container {
      margin-bottom: 30px;
    }

    .search-container.hidden {
      display: none;
    }

    .search-input-group {
      display: flex;
      gap: 10px;
    }

    .search-input {
      flex: 1;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
    }

    .search-input:focus {
      outline: none;
      border-color: #666;
    }

    .search-input:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    .search-button {
      padding: 10px 20px;
      background: #000;
      color: white;
      border: none;
      font-size: 16px;
      cursor: pointer;
    }

    .search-button:hover:not(:disabled) {
      background: #333;
    }

    .search-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .result-item {
      padding: 20px;
      border: 1px solid #eee;
      margin-bottom: 15px;
      background: white;
    }

    .result-title {
      font-size: 18px;
      font-weight: 500;
      margin-bottom: 8px;
    }

    .result-title a {
      color: #000;
      text-decoration: none;
    }

    .result-title a:hover {
      text-decoration: underline;
    }

    .result-author {
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
    }

    .result-description {
      color: #333;
      margin-bottom: 10px;
      line-height: 1.4;
    }

    .result-similarity {
      font-size: 12px;
      color: #999;
    }

    .show-more-container {
      text-align: center;
      margin: 20px 0;
    }

    .show-more-btn {
      padding: 8px 16px;
      background: #f5f5f5;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 14px;
      color: #333;
    }

    .show-more-btn:hover {
      background: #eee;
    }

    .no-results {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .searching {
      text-align: center;
      padding: 20px;
      color: #333;
    }

    /* Mobile */
    @media (max-width: 600px) {
      body {
        padding: 15px;
      }

      .model-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .model-controls select {
        min-width: auto;
      }

      .search-input-group {
        flex-direction: column;
      }

      .result-item {
        padding: 15px;
      }
    }
  </style>
  <script type="module">
    import {pipeline} from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.1';

    const ring = [
      {
        url: "https://maxbo.me",
        name: "Max Bo",
        feed: "https://maxbo.me/atom.xml",
      },
      {
        url: "https://liamzebedee.com",
        name: "Liam Zebedee",
        feed: "https://liamzebedee.com/index.xml",
      },
      {
        url: "https://borretti.me",
        name: "Fernando Borretti",
        feed: "https://borretti.me/feed.xml",
      },
      {
        url: "https://ethansmith2000.com",
        name: "Ethan Smith",
        feed: "https://www.ethansmith2000.com/blog-feed.xml",
      },
      {
        url: "https://tomlister.net",
        name: "Tom Lister",
        feed: "https://tomlister.net/feed.xml",
      }
    ];

    const proxyURL = "https://tomlister--95ced61c6f4c11f0bd4b0224a6c84d84.web.val.run/?feed=";

    let embedder = null;
    let isLoadingModel = false;
    let loadingTimer = null;
    let loadingStartTime = null;

    const availableModels = [
      {id: 'Xenova/all-MiniLM-L6-v2', name: 'MiniLM L6 v2 (Fast, Small)', size: '~23MB'},
      {id: 'Xenova/all-mpnet-base-v2', name: 'MPNet Base v2 (Better Quality)', size: '~438MB'},
      {id: 'Xenova/bge-small-en-v1.5', name: 'BGE Small (Balanced)', size: '~133MB'},
      {id: 'Xenova/sentence-transformers-all-MiniLM-L6-v2', name: 'Sentence Transformers MiniLM', size: '~91MB'}
    ];

    const initEmbeddings = async (modelId = 'Xenova/all-MiniLM-L6-v2') => {
      if (embedder && embedder.model && embedder.model.config.name_or_path === modelId) {
        console.log("Same model already loaded");
        return embedder;
      }

      if (isLoadingModel) {
        console.log("Model loading in progress...");
        return null;
      }

      if (embedder) {
        console.log("Clearing previous model...");
        embedder = null;
        window.embedder = null;
      }

      isLoadingModel = true;
      loadingStartTime = Date.now();

      const updateTimer = () => {
        const elapsed = Math.floor((Date.now() - loadingStartTime) / 1000);
        const statusDiv = document.getElementById('status');
        if (statusDiv && !statusDiv.textContent.includes('Downloading')) {
          statusDiv.textContent = `Loading model: ${elapsed}s`;
        }
      };

      loadingTimer = setInterval(updateTimer, 1000);
      updateTimer();

      try {
        console.log(`Loading embedding model: ${modelId}`);
        embedder = await pipeline('feature-extraction', modelId, {
          dtype: 'q8',
          progress_callback: (progress) => {
            const elapsed = Math.floor((Date.now() - loadingStartTime) / 1000);
            const statusDiv = document.getElementById('status');
            if (progress.status === 'download') {
              if (statusDiv) {
                statusDiv.textContent = `Downloading ${progress.name}: ${elapsed}s`;
              }
            }
          }
        });
        window.embedder = embedder;
        console.log(`Embedding model loaded: ${modelId}`);
        return embedder;
      } finally {
        isLoadingModel = false;
        if (loadingTimer) {
          clearInterval(loadingTimer);
          loadingTimer = null;
        }
      }
    };

    const getFeedProxy = async ({feed, name, modelId}) => {
      const response = await fetch(proxyURL + feed);
      const text = await response.text();
      const parser = new DOMParser();
      const xml = parser.parseFromString(text, "application/xml");
      return await parseFeed(xml, name, modelId);
    }

    const parseFeed = async (xml, authorName, modelId) => {
      const isAtom = xml.querySelector("feed") || xml.querySelector("entry");
      const isRSS = xml.querySelector("rss") || xml.querySelector("item");

      let items;
      if (isAtom) {
        items = xml.querySelectorAll("entry");
        console.log(`Processing Atom feed for ${authorName} with model ${modelId}...`);
      } else if (isRSS) {
        items = xml.querySelectorAll("item");
        console.log(`Processing RSS feed for ${authorName} with model ${modelId}...`);
      } else {
        console.warn(`Unknown feed format for ${authorName} with model ${modelId}, trying both entry and item selectors...`);
        items = xml.querySelectorAll("entry, item");
      }

      const results = [];
      const maxItems = 15;

      const itemsToProcess = Array.from(items).slice(0, maxItems);
      const cachedArticles = loadCachedArticles(modelId);

      console.log(`Processing ${itemsToProcess.length} items from feed for ${authorName} with model ${modelId}...`);

      for (const item of itemsToProcess) {
        let title, description, link;

        if (isAtom) {
          title = item.querySelector("title")?.textContent || "";
          description = item.querySelector("summary")?.textContent ||
            item.querySelector("content")?.textContent || "";
          const linkEl = item.querySelector("link");
          if (linkEl) {
            link = linkEl.getAttribute("href") || linkEl.textContent || "";
          } else {
            link = "";
          }
        } else {
          title = item.querySelector("title")?.textContent || "";
          // Try content:encoded first (full content), then fall back to description
          const contentEncoded = item.querySelector("content\\:encoded")?.textContent || 
                                 item.querySelector("encoded")?.textContent || "";
          description = contentEncoded || 
                       item.querySelector("description")?.textContent || "";
          link = item.querySelector("link")?.textContent || "";
        }

        if (!title.trim()) continue;

        // Generate hash for this article
        const articleData = { title, link, author: authorName };
        const articleHash = generateArticleHash(articleData);

        // Check if we have this article in cache
        if (cachedArticles[articleHash]) {
          console.log("Using cached article:", title.substring(0, 40) + "...");
          results.push({
            ...cachedArticles[articleHash],
            author: authorName // Ensure author is set correctly
          });
          continue;
        }

        // Strip HTML tags from description if it contains them
        let cleanDescription = description;
        if (description.includes('<')) {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = description;
          cleanDescription = tempDiv.textContent || tempDiv.innerText || '';
        }

        console.log("Processing new article:", title.substring(0, 60) + "...");

        let embedding = null;
        const currentEmbedder = embedder || window.embedder;
        if (currentEmbedder && title) {
          try {
            // Use more content for better embeddings, but limit to 2000 chars for performance
            const textToEmbed = (title + " " + cleanDescription).substring(0, 2000);
            const embeddingResult = await currentEmbedder(textToEmbed, {
              pooling: 'mean',
              normalize: true
            });
            embedding = Array.from(embeddingResult.data);
          } catch (error) {
            console.error("Failed to generate embedding for:", title.substring(0, 40), error);
            throw error;
          }
        } else {
          throw new Error("Embedding model not available!");
        }

        const processedArticle = {
          title,
          description: cleanDescription.substring(0, 500),
          link,
          embedding,
          author: authorName
        };

        // Cache this article
        cachedArticles[articleHash] = processedArticle;
        results.push(processedArticle);
      }

      // Save updated cache
      saveCachedArticles(cachedArticles, modelId);

      console.log(`Processed ${results.length} items with embeddings for ${authorName} with model ${modelId}`);
      return results;
    }

    const getFeeds = async (currentModelId) => {
      const allFeeds = [];
      const totalFeeds = ring.length;
      
      for (let i = 0; i < ring.length; i++) {
        const author = ring[i];
        const progress = i + 1;
        
        // Update status with progress
        if (window.updateStatus) {
          window.updateStatus(`Processing feeds (${progress}/${totalFeeds}): ${author.name}...`);
        }
        
        try {
          const feedItems = await getFeedProxy({
            feed: author.feed, 
            name: author.name, 
            modelId: currentModelId
          });
          allFeeds.push(...feedItems);
        } catch (error) {
          console.error(`Failed to process feed for ${author.name}:`, error);
          // Continue with other feeds even if one fails
        }
      }
      
      return allFeeds;
    }

    const cosineSimilarity = (a, b) => {
      const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
      const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
      const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
      return dotProduct / (magnitudeA * magnitudeB);
    };

    // Cache management functions
    const CACHE_KEY = 'matcha_search_cache';
    const MODEL_PREF_KEY = 'matcha_model_preference';
    const CACHE_VERSION = '1.0';

    const saveModelPreference = (modelId) => {
      try {
        localStorage.setItem(MODEL_PREF_KEY, modelId);
      } catch (error) {
        console.warn('Failed to save model preference:', error);
      }
    };

    const loadModelPreference = () => {
      try {
        return localStorage.getItem(MODEL_PREF_KEY) || 'Xenova/all-MiniLM-L6-v2';
      } catch (error) {
        console.warn('Failed to load model preference:', error);
        return 'Xenova/all-MiniLM-L6-v2';
      }
    };

    const generateArticleHash = (article) => {
      // Create a simple hash from title + link + author for cache key
      const text = `${article.title}|${article.link}|${article.author}`;
      let hash = 0;
      for (let i = 0; i < text.length; i++) {
        const char = text.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return hash.toString();
    };

    const loadCachedArticles = (modelId) => {
      try {
        const cached = localStorage.getItem(CACHE_KEY);
        if (!cached) return {};
        
        const data = JSON.parse(cached);
        if (data.version !== CACHE_VERSION || data.modelId !== modelId) {
          console.log('Cache version mismatch or different model, clearing cache');
          localStorage.removeItem(CACHE_KEY);
          return {};
        }
        
        console.log(`Loaded ${Object.keys(data.articles || {}).length} cached articles`);
        return data.articles || {};
      } catch (error) {
        console.warn('Failed to load cached articles:', error);
        return {};
      }
    };

    const saveCachedArticles = (articles, modelId) => {
      try {
        const cacheData = {
          version: CACHE_VERSION,
          modelId: modelId,
          timestamp: Date.now(),
          articles: articles
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
        console.log(`Cached ${Object.keys(articles).length} articles`);
      } catch (error) {
        console.warn('Failed to save cached articles:', error);
      }
    };

    const clearCache = () => {
      try {
        localStorage.removeItem(CACHE_KEY);
        console.log('Cache cleared');
      } catch (error) {
        console.warn('Failed to clear cache:', error);
      }
    };

    const searchItems = async (query, items, topK = 5) => {
      const currentEmbedder = embedder || window.embedder;

      if (!currentEmbedder) {
        throw new Error("Embedding model not loaded! Cannot perform semantic search.");
      }

      if (!query.trim()) return [];

      console.log(`Searching for: "${query}"`);

      const queryEmbedding = await currentEmbedder(query, {pooling: 'mean', normalize: true});
      const queryVector = Array.from(queryEmbedding.data);

      const results = items
        .filter(item => item.embedding)
        .map(item => ({
          ...item,
          similarity: (cosineSimilarity || window.cosineSimilarity)(queryVector, item.embedding)
        }))
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, topK);

      console.log(`Found ${results.length} results`);
      return results;
    };

    let allFeedItems = [];

    const populateModelSelect = () => {
      const modelSelect = document.getElementById('modelSelect');
      modelSelect.innerHTML = '';

      const savedModel = window.loadModelPreference();

      window.availableModels.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = `${model.name} (${model.size})`;
        if (model.id === savedModel) {
          option.selected = true;
        }
        modelSelect.appendChild(option);
      });
    };

    const updateStatus = (text, isError = false, hideLoader = false) => {
      const statusText = document.getElementById('statusText');
      const loaderContainer = document.getElementById('loaderContainer');
      const searchContainer = document.getElementById('searchContainer');
      
      statusText.textContent = text;
      statusText.className = isError ? 'status-text error' : 'status-text';
      
      if (hideLoader) {
        loaderContainer.classList.add('hidden');
        searchContainer.classList.remove('hidden');
      } else {
        loaderContainer.classList.remove('hidden');
        searchContainer.classList.add('hidden');
      }
    };

    const main = async () => {
      const searchInput = document.getElementById('searchInput');
      const searchButton = document.getElementById('searchButton');
      const modelSelect = document.getElementById('modelSelect');

      populateModelSelect();

      window.handleModelChange();

      try {
        const selectedModel = modelSelect.value;
        window.updateStatus(`Loading embedding model: ${selectedModel}...`);

        await window.initEmbeddings(selectedModel);

        window.updateStatus("Processing feeds...");

        console.log("Fetching feeds...");
        allFeedItems = await window.getFeeds(selectedModel);
        window.allFeedItems = allFeedItems;
        console.log(`Processed ${allFeedItems.length} blog posts.`);

        // Hide loader and show search
        window.updateStatus(`Loaded ${allFeedItems.length} blog posts.`, false, true);
        searchInput.disabled = false;
        searchButton.disabled = false;
        searchInput.focus();

      } catch (error) {
        console.error("Error in main:", error);
        window.updateStatus("Failed to load embedding model. Check console for details.", true);
      }
    };

    // Expose functions to window for cross-context access
    window.searchItems = searchItems;
    window.allFeedItems = allFeedItems;
    window.cosineSimilarity = cosineSimilarity;
    window.availableModels = availableModels;
    window.initEmbeddings = initEmbeddings;
    window.getFeeds = getFeeds;
    window.clearCache = clearCache;
    window.loadCachedArticles = loadCachedArticles;
    window.saveCachedArticles = saveCachedArticles;
    window.saveModelPreference = saveModelPreference;
    window.loadModelPreference = loadModelPreference;
    window.CACHE_KEY = CACHE_KEY;
    window.updateStatus = updateStatus;

    document.addEventListener("DOMContentLoaded", () => {
      main();
    })
  </script>
</head>

<body>
  <div class="header">
    <h1>matcha search</h1>
    <p>semantically searches the collective knowledge of the <a href="https://matchamonday.net">matcha monday</a> webring</p>
    <button class="settings-button" onclick="openSettings()"><i class="fas fa-cog"></i></button>
  </div>

  <div id="loaderContainer" class="loader-container">
    <img src="matcha.gif" alt="Loading..." class="matcha-loader">
    <div id="statusText" class="status-text">Loading embedding model...</div>
  </div>

  <div id="searchContainer" class="search-container hidden">
    <div class="search-input-group">
      <input type="text" id="searchInput" class="search-input" placeholder="Search blog posts..." disabled>
      <button onclick="performSearch()" class="search-button" disabled id="searchButton">Search</button>
    </div>
  </div>

  <div id="results" class="results"></div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Settings</div>
        <button class="close-button" onclick="closeSettings()">&times;</button>
      </div>
      <div class="model-selector">
        <div class="model-controls">
          <label for="modelSelect">Model:</label>
          <select id="modelSelect" onchange="handleModelChange()"></select>
          <button onclick="reloadModel()" id="reloadButton">Load</button>
        </div>
      </div>
      <div class="cache-management">
        <div class="model-controls">
          <label>Cache:</label>
          <button onclick="clearCacheAndReload()" id="clearCacheButton">Clear Cache</button>
          <span id="cacheInfo" style="font-size: 12px; color: #666; margin-left: 10px;"></span>
        </div>
      </div>
    </div>
  </div>

  <script>
    window.openSettings = () => {
      document.getElementById('settingsModal').style.display = 'block';
    };

    window.closeSettings = () => {
      document.getElementById('settingsModal').style.display = 'none';
    };

    // Close modal when clicking outside of it
    window.onclick = (event) => {
      const modal = document.getElementById('settingsModal');
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    };

    window.handleModelChange = () => {
      const modelSelect = document.getElementById('modelSelect');
      const reloadButton = document.getElementById('reloadButton');
      const selectedModel = window.availableModels.find(m => m.id === modelSelect.value);

      if (selectedModel) {
        reloadButton.textContent = `Load`;
        // Save the model preference
        window.saveModelPreference(modelSelect.value);
      }
    };

    window.reloadModel = async () => {
      const searchInput = document.getElementById('searchInput');
      const searchButton = document.getElementById('searchButton');
      const modelSelect = document.getElementById('modelSelect');
      const reloadButton = document.getElementById('reloadButton');

      searchInput.disabled = true;
      searchButton.disabled = true;
      reloadButton.disabled = true;

      window.allFeedItems = [];

      try {
        const selectedModel = modelSelect.value;
        
        // Show loader and hide search
        const searchContainer = document.getElementById('searchContainer');
        const loaderContainer = document.getElementById('loaderContainer');
        searchContainer.classList.add('hidden');
        loaderContainer.classList.remove('hidden');
        
        window.updateStatus(`Loading embedding model: ${selectedModel}...`);

        await window.initEmbeddings(selectedModel);

        window.updateStatus("Processing feeds with new model...");

        const newFeedItems = await window.getFeeds(selectedModel);
        window.allFeedItems = newFeedItems;

        window.updateStatus(`Loaded ${newFeedItems.length} blog posts.`, false, true);
        searchInput.disabled = false;
        searchButton.disabled = false;
        searchInput.focus();

      } catch (error) {
        console.error("Error loading model:", error);
        window.updateStatus("Failed to load model. Check console for details.", true);
      } finally {
        reloadButton.disabled = false;
      }
    };

    window.performSearch = async () => {
      const query = document.getElementById('searchInput').value;
      if (!query.trim()) return;

      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '<div class="searching">Searching...</div>';

      try {
        console.log('Searching for:', query);
        console.log('Available items:', window.allFeedItems?.length);
        console.log('Embedder available:', !!window.embedder);

        const results = await window.searchItems(query, window.allFeedItems);

        if (results.length === 0) {
          resultsDiv.innerHTML = '<div class="no-results">No results found.</div>';
          return;
        }

        const threshold = 0.30;
        const highQualityResults = results.filter(item => item.similarity >= threshold);
        const lowQualityResults = results.filter(item => item.similarity < threshold);

        const renderResults = (items, showSimilarity = true) => {
          return items.map(item => `
            <div class="result-item">
              <div class="result-title"><a href="${item.link}" target="_blank">${item.title}</a></div>
              <div class="result-author">By ${item.author}</div>
              <div class="result-description">${item.description || 'No description available'}</div>
              ${showSimilarity ? `<div class="result-similarity">Similarity: ${(item.similarity * 100).toFixed(1)}%</div>` : ''}
            </div>
          `).join('');
        };

        let html = '';
        if (highQualityResults.length > 0) {
          html += renderResults(highQualityResults);
        } else {
          html += '<div class="no-results">No high-confidence results found.</div>';
        }

        if (lowQualityResults.length > 0) {
          html += `
            <div id="showMoreContainer" class="show-more-container">
              <button id="showMoreBtn" onclick="toggleLowQualityResults()" class="show-more-btn">
                Show ${lowQualityResults.length} more result${lowQualityResults.length > 1 ? 's' : ''} (lower similarity)
              </button>
            </div>
            <div id="lowQualityResults" style="display: none;">
              ${renderResults(lowQualityResults)}
            </div>
          `;
        }

        resultsDiv.innerHTML = html;

      } catch (error) {
        resultsDiv.innerHTML = '<div class="no-results">Search error. Check console for details.</div>';
        console.error('Search error:', error);
      }
    };

    window.toggleLowQualityResults = () => {
      const lowQualityDiv = document.getElementById('lowQualityResults');
      const showMoreBtn = document.getElementById('showMoreBtn');

      if (lowQualityDiv.style.display === 'none') {
        lowQualityDiv.style.display = 'block';
        showMoreBtn.textContent = 'Hide lower similarity results';
      } else {
        lowQualityDiv.style.display = 'none';
        const hiddenCount = lowQualityDiv.children.length;
        showMoreBtn.textContent = `Show ${hiddenCount} more result${hiddenCount > 1 ? 's' : ''} (lower similarity)`;
      }
    };

    document.getElementById('searchInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        performSearch();
      }
    });

    window.clearCacheAndReload = () => {
      if (confirm('This will clear all cached articles and reload the page. Continue?')) {
        window.clearCache();
        location.reload();
      }
    };

    window.updateCacheInfo = () => {
      const cacheInfo = document.getElementById('cacheInfo');
      if (cacheInfo) {
        try {
          const cached = localStorage.getItem(window.CACHE_KEY);
          if (cached) {
            const data = JSON.parse(cached);
            const itemCount = Object.keys(data.articles || {}).length;
            const size = (new Blob([cached]).size / 1024).toFixed(1);
            cacheInfo.textContent = `${itemCount} articles cached (${size}KB)`;
          } else {
            cacheInfo.textContent = 'No cache';
          }
        } catch (error) {
          cacheInfo.textContent = 'Cache error';
        }
      }
    };

    // Update cache info when settings modal opens
    const originalOpenSettings = window.openSettings;
    window.openSettings = () => {
      originalOpenSettings();
      setTimeout(updateCacheInfo, 100);
    };
  </script>
</body>

</html>
